- 서버에서 HTML 문서를 응답할 때 CSP를 적용하려면 어떤 HTTP 응답 헤더를 설정해야 하나요? 블로그에 나온 Express.js 코드 예시를 기반으로 설명해보세요.
    
    res.setHeader('Content-Security-Policy', "default-src 'self'");
    
- `default-src 'self'` 설정은 브라우저에게 어떤 보안 정책을 의미하나요? 또한 `'self'` 값은 어떤 출처를 포함하거나 제외하나요?
    
    현재 출처의 자원만 사용하도록 하는 것이다.
    
- 블로그에 나온 악성 스크립트(`<script>fetch(...)</script>`)를 주입했을 때 CSP가 어떻게 동작하는지 네트워크 탭과 콘솔 메시지 측면에서 설명해보세요.
    
    hacker.com으로 네트워크 요청이 발생하지 않았으며, 브라우저 콘솔에는 경고가 표시된다.
    
- 기본 CSP 설정에서 인라인 스타일이 차단된다고 했습니다. 블로그 예시 중 `width:600px`이 적용되지 않는 이유를 설명하세요.
    
    CSP는 인라인 스크립트뿐 아니라 인라인 스타일까지 차단하여 보안을 강화하기 때문에, 인라인 스타일이 적용되지 않았다.
    
- 구글 애널리틱스, 카카오맵, 외부 API 등이 CSP 때문에 차단될 수 있다고 했습니다. 이러한 현상을 "건물 보안을 강화한다"는 비유와 연결해 설명해보세요.
    
    보안을 강화하기 위해 모든 출입구를 막아서 아예 들어오지 못하는 경우
    
- Report-Only 모드에서는 실제 리소스 실행이 차단되지 않습니다. 그 대신 브라우저와 서버에서 각각 어떤 동작을 수행하나요?
    
    서버: 리포트 받기 
    
    브라우저: 정책 위반을 진단만 하고 리소스 로드 차단 안하고 실행하고 진단 결과 서버로 보
    
- CSP만으로는 CSRF를 막을 수 없다고 했습니다. 블로그에 정리된 다른 보안 조치들(SameSite 쿠키, X-Frame-Options 등) 중 2가지를 설명하세요.
    
    SameSite로 CSRF 공격을 방어하거나, X-Frame-Options로 클릭재킹 방어를 할 수 있다.

- 출처(Origin)는 어떤 세 요소의 조합으로 결정되나요?
    
    프로토콜, 도메인, 포트
    
- 출처의 요소가 다른 경우(예: 프로토콜만, 포트만 다른 경우)에 같은 출처인지 아닌지를 예시 3개(같은 출처 1개, 다른 출처 2개)로 설명하세요.
    
    세가지가 모두 일치해야만 같은 출처로 간주한다.
    http://app.com:1234와 http://example.com:1234는 도메인이 달라 다른 출처이며, http://app.com:3234 포트가 달라 다른 출력이다.
    
- 블로그에 나온 `fetch` 기반 악성 스크립트를 다른 출처로 실행했을 때 브라우저에서 어떤 일이 발생하나요? 네트워크 전송 여부, 응답 사용 가능성, 브라우저 콘솔 메시지 측면에서 서술하세요.
    
    네트워크 요청은 전송되나 응답 데이터는 사용할 수 없고 동일 출처 정책으로 원격 리소스 차단함을 오류 메세지로 출력한다.
    
- SOP가 어떻게 Session Hijacking(세션 하이재킹) 시도를 방지하는지 구체적으로 설명하세요. SOP가 차단하는 것과 허용되는 것(예: 네트워크 요청은 나가지만 응답 데이터에 접근 불가)을 포함하세요.
    
    네트워크 요청은 나가나 응답 데이터는 사용할 수 없고 브라우저가 오류를 발생시킨다.
    
- 블로그에서 명시한 대로 SOP가 반드시 동일 출처에서만 접근하도록 하는 주요 브라우저 API/리소스 3가지를 쓰고, 각각에 대해 간단한 설명(왜 제한되는지)을 덧붙이세요.
    
    웹 폰트: 폰트 파일은 브라우저 내부에서 캐싱 및 렌더링에 직접 사용돼서, XMLHttpRequest: 공격자가 사용자의 브라우저를 통해 다른 사이트의 개인 데이터나 세션 정보를 탈취할 수 있어서, fetch(): 네트워크 요청을 매우 쉽게 보낼 수 있어서
    
- SOP와 CSP의 차이를 블로그 내용에 따라 요점 4개(각 항목 1문장)로 정리하세요. (예: 누가 적용하는가, 제어 주체, 설정 가능 여부 등)
    
    SOP는 서버 개입 없이 브라우저가 자체적으로 적용하나, CSP는 서버에서 정책을 설정하고 브라우저가 실행한다.
    
    SOP는 별도 설정 없이 모든 웹페이지에 기본 적용하나 CSP는 HTTP 응답 헤더를 통해 정책을 전달한다.
    
    세부 동작이 브라우저마다 약간씩 다른 SOP와 달리 CSP는 각 서비스의 요구사항에 맞게 조정 가능하고, 개발자가 직접 제어할 수 없는 SOP와 단계적 적용 가능한 CSP가 있다.
    
- 브라우저에서 SOP 관련 차단 오류를 발견했을 때(예: 콘솔에 “동일 출처 정책으로 인해 ... 차단했습니다” 메시지) 문제 원인 파악을 위한 체크리스트(최소 3항목)를 작성하고, 임시·영구 대응 방안(각 1~2줄)도 제시하세요.
    
    출처 비교, 응답 헤더 확인, 요청 유형 확인
    
    기본 CORS 허용

- 브라우저에서 `http://localhost:8080` 애플리케이션이 `http://localhost:8081/resource.json`을 요청했을 때, 네트워크 요청과 응답은 어떻게 처리되며, 브라우저가 응답 본문을 사용하지 못하는 이유는 무엇인가요?
    
    8081번 포트로 요청을 보내고 응답도 받았으나, 스크립트에서 응답 본문을 사용할 수 없다는 메세지가 표시된다. 동일 출처 정책 때문이다.
    
- 서버가 다른 출처(`http://localhost:8080`)에서 자원을 사용할 수 있게 하려면 어떤 응답 헤더를 어떻게 설정해야 하나요? 글의 예시 코드를 참고해 헤더 이름과 값까지 구체적으로 쓰세요.
    
    Access-Control-Allow-Origin 헤더를 확인하고 현재 출처가 포함돼 있는지 검사하고 서버가 해당 출처를 허용했는지 판단하기에, res.setHeader('Access-Control-Allow-Origin', '[http://localhost:8080](http://localhost:8080/)'); 와 같이 출처를 허용해야한다. 
    
- 단순 요청으로 분류되기 위해서는 어떤 두 가지 조건을 만족해야 하나요? 또한 `GET /resource.json` 요청이 단순 요청에 해당하는 이유를 설명하세요.
    
    허용된 HTTP 메소드(GET, POST, HEAD)를 사용해야하며, 안전한 헤더(Accept, Accept-Language, Content-Language, Content-Type, Range)를 사용하면 된다.  
    
- 브라우저에서 `X-Goguma`라는 커스텀 헤더를 추가했을 때 왜 차단이 발생하나요? 이 문제를 해결하기 위해 서버에서 추가해야 하는 응답 헤더와 값은 무엇인가요?
    
    동일 출처 정책 때문이고, res.setHeader('Access-Control-Allow-Headers', 'X-Goguma');를 추가해야한다.
    
- `PUT` 요청을 보낼 때 브라우저는 왜 먼저 `OPTIONS` 요청을 보내나요? 이때 브라우저가 보내는 헤더와 서버가 응답해야 하는 헤더를 각각 쓰고, 사전 요청과 실제 요청이 어떻게 이어지는지 간단히 서술하세요.
    
    서버가 요청을 보내 측이 브라우저가 아닐 수도 있다고 판단하기에 먼저 서로를 확인하려고 사전 요청을 보낸다.  res.setHeader('Access-Control-Allow-Methods', 'PUT');

    - **RBAC**의 한계에 대해 설명해주세요.
    
    서비스가 커지면(=복잡한 권한 케이스의 경우) 한계가 존재한다.
    
- **ABAC**으로의 전환, 어떤 '기준'이 적절할까요?
    
    역할만으로는 표현 불가능한 권한이 필요할 떄
    
- 어떤 서비스 영역에 **RBAC**을 남겨두고, **ABAC**을 도입하시겠어요?
    
    RBAC는 고정될 경우, ABAC는 복잡한 조건이 있을 경우
    
- 여러분들은 다른 부서에서 요청을 받았을 때 어떤식으로 행동하실껀가요?
    
    어떤 것이 좋은지 생각해본다.